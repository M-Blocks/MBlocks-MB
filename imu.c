/*
 * imu.c
 *
 *  Created on: Apr 3, 2014
 *      Author: kwgilpin
 */

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>

#include "nrf_delay.h"

#include "app_timer.h"

#include "util.h"

#include "global.h"
#include "util.h"
#include "twi_master.h"
#include "mpu6050.h"
#include "imu.h"

#define DEBUG_IMU 					0
#define ORIGINAL_DMP_CODE			0

#define MPU6050_DMP_CODE_SIZE		1929 // dmpMemory[]
#define MPU6050_DMP_CONFIG_SIZE		192 // dmpConfig[]
#define MPU6050_DMP_UPDATES_SIZE	47 // dmpUpdates[]

typedef struct {
    uint8_t bank;
    uint8_t address;
    uint8_t size;
    uint8_t data[];
} dmpUpdate_t;

static const unsigned char dmpMemory[MPU6050_DMP_CODE_SIZE] = {
    // bank 0, 256 bytes
    0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
    0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
    0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
    0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,

    // bank 1, 256 bytes
    0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
    0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
    0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
    0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,

    // bank 2, 256 bytes
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // bank 3, 256 bytes
    0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
    0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
    0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
    0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
    0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
    0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
    0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
    0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
    0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
    0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
    0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
    0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
    0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
    0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
    0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
    0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,

    // bank 4, 256 bytes
    0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
    0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
    0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
    0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
    0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
    0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
    0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
    0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
    0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
    0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
    0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
    0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,

    // bank 5, 256 bytes
    0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
    0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
    0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
    0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
    0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
    0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
    0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
    0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
    0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
    0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
    0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
    0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
    0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
    0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
    0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
    0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,

    // bank 6, 256 bytes
    0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
    0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
    0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
    0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
    0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
    0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
    0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
    0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
    0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
    0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
    0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
    0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
    0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
    0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
    0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
    0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,

    // bank 7, 138 bytes (remainder)
    0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
    0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
    0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
    0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
    0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
    0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
    0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
    0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
    0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
};

static const unsigned char dmpConfig[MPU6050_DMP_CONFIG_SIZE] = {
// BANK OFFSET LENGTH [DATA]
    0x03, 0x7B, 0x03, 0x4C, 0xCD, 0x6C, // FCFG_1 inv_set_gyro_calibration
    0x03, 0xAB, 0x03, 0x36, 0x56, 0x76, // FCFG_3 inv_set_gyro_calibration
    0x00, 0x68, 0x04, 0x02, 0xCB, 0x47, 0xA2, // D_0_104 inv_set_gyro_calibration
    0x02, 0x18, 0x04, 0x00, 0x05, 0x8B, 0xC1, // D_0_24 inv_set_gyro_calibration
    0x01, 0x0C, 0x04, 0x00, 0x00, 0x00, 0x00, // D_1_152 inv_set_accel_calibration
    0x03, 0x7F, 0x06, 0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_accel_calibration
    0x03, 0x89, 0x03, 0x26, 0x46, 0x66, // FCFG_7 inv_set_accel_calibration
    0x00, 0x6C, 0x02, 0x20, 0x00, // D_0_108 inv_set_accel_calibration
    0x02, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_00 inv_set_compass_calibration
    0x02, 0x44, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_01
    0x02, 0x48, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_02
    0x02, 0x4C, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_10
    0x02, 0x50, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_11
    0x02, 0x54, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_12
    0x02, 0x58, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_20
    0x02, 0x5C, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_21
    0x02, 0xBC, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_22
    0x01, 0xEC, 0x04, 0x00, 0x00, 0x40, 0x00, // D_1_236 inv_apply_endian_accel
    0x03, 0x7F, 0x06, 0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_mpu_sensors
    0x04, 0x02, 0x03, 0x0D, 0x35, 0x5D, // CFG_MOTION_BIAS inv_turn_on_bias_from_no_motion
    0x04, 0x09, 0x04, 0x87, 0x2D, 0x35, 0x3D, // FCFG_5 inv_set_bias_update
    0x00, 0xA3, 0x01, 0x00, // D_0_163 inv_set_dead_zone
    // SPECIAL 0x01 = enable interrupts
    0x00, 0x00, 0x00, 0x01, // SET INT_ENABLE at i=22, SPECIAL INSTRUCTION
    0x07, 0x86, 0x01, 0xFE, // CFG_6 inv_set_fifo_interupt
    0x07, 0x41, 0x05, 0xF1, 0x20, 0x28, 0x30, 0x38, // CFG_8 inv_send_quaternion
    0x07, 0x7E, 0x01, 0x30, // CFG_16 inv_set_footer
    0x07, 0x46, 0x01, 0x9A, // CFG_GYRO_SOURCE inv_send_gyro
    0x07, 0x47, 0x04, 0xF1, 0x28, 0x30, 0x38, // CFG_9 inv_send_gyro -> inv_construct3_fifo
    0x07, 0x6C, 0x04, 0xF1, 0x28, 0x30, 0x38, // CFG_12 inv_send_accel -> inv_construct3_fifo
    0x02, 0x16, 0x02, 0x00, 0x01 // D_0_22 inv_set_fifo_rate

    // This very last 0x01 WAS a 0x09, which drops the FIFO rate down to 20 Hz. 0x07 is 25 Hz,
    // 0x01 is 100Hz. Going faster than 100Hz (0x00=200Hz) tends to result in very noisy data.
    // DMP output frequency is calculated easily using this equation: (200Hz / (1 + value))

    // It is important to make sure the host processor can keep up with reading and processing
    // the FIFO output at the desired rate. Handling FIFO overflow cleanly is also a good idea.
};


static const dmpUpdate_t dmpUpdate0 = {0x01, 0xB2, 0x02, {0xFF, 0xFF}};
static const dmpUpdate_t dmpUpdate1 = {0x01, 0x90, 0x04, {0x09, 0x23, 0xA1, 0x35}};
static const dmpUpdate_t dmpUpdate2 = {0x01, 0x6A, 0x02, {0x06, 0x00}};
static const dmpUpdate_t dmpUpdate3 = {0x01, 0x60, 0x08, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
static const dmpUpdate_t dmpUpdate4 = {0x00, 0x60, 0x04, {0x40, 0x00, 0x00, 0x00}};
static const dmpUpdate_t dmpUpdate5 = {0x01, 0x62, 0x02, {0x00, 0x00}};
static const dmpUpdate_t dmpUpdate6 = {0x00, 0x60, 0x04, {0x00, 0x40, 0x00, 0x00}};

static const dmpUpdate_t *dmpUpdates[7] = {
    &dmpUpdate0,
    &dmpUpdate1,
    &dmpUpdate2,
    &dmpUpdate3,
    &dmpUpdate4,
    &dmpUpdate5,
    &dmpUpdate6
};

/* These vectors are ordered so that "forward" plane changes progress through
 * the vectors in increasing order. */
const vectorFloat_t frameAlignmentVectorsFloat[3] = {
    {0.0f, 0.0f, 1.0f},
    {0.707107f, -0.707107f, 0.0f},
    {0.707107f, 0.707107f, 0.0f},
};

static bool imuInitialized[2] = {false, false};
static bool dmpInitialized[2] = {false, false};

static bool imu_writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize);

static void imu_setIMUInitialized(bool initialized);
static bool imu_getIMUInitialized(void);

static void imu_setDMPInitialized(bool initialized);
static bool imu_getDMPInitialized(void);


bool imu_init() {
    bool success = true;
    uint8_t whoAmI;

    twi_master_init();

    success &= mpu6050_getWhoAmI(&whoAmI);
    if (!success || (whoAmI != (mpu6050_getAddress() >> 1))) {
	return false;
    }

    /* Reset the gyro, accelerometer, and temperature signal paths */
    success &= mpu6050_resetSignalPaths();
    /* Perform device reset */
    success &= mpu6050_reset();

    /* The device reset requires that we re-initialize the DMP */
    imu_setDMPInitialized(false);

    /* Disable all interrupts */
    success &= mpu6050_writeReg(MPU6050_INT_ENABLE_REG_ADDR, 0x00);

    if (success) {
	imu_setIMUInitialized(true);
    } else {
	imu_setIMUInitialized(false);
    }

    twi_master_deinit();

    return success;
}

bool imu_initDMP() {

    uint8_t hwRevision;
    bool otpValid;
    int8_t xgOffsetTC, ygOffsetTC, zgOffsetTC;
    uint16_t fifoCount;
    uint8_t fifoBuffer[128];
    uint8_t intStatus;
    bool success = true;

    if (!imu_getIMUInitialized()) {
	return false;
    }

    twi_master_init();

#if (DEBUG_IMU == 1)
    char str[64];
    app_uart_put_string("Initializing IMU DMP\r\n");
#endif

    /* Reset the IMU */
    mpu6050_reset();
    nrf_delay_ms(30);

    /* Bring the IMU out of sleep mode, which it enters automatically after
     * reset. */
    success &= mpu6050_setSleepEnabled(false);

    /* Read the hardware version from user bank 16, byte 6 */
    success &= mpu6050_setMemoryBank(0x10, true, true);
    success &= mpu6050_setMemoryStartAddress(0x06);
    success &= mpu6050_readMemoryByte(&hwRevision);
    success &= mpu6050_setMemoryBank(0x00, false, false);
#if (DEBUG_IMU == 1)
    snprintf(str, sizeof(str), "IMU hardware revision as per user[16][6] = %02X\r\n", hwRevision);
    app_uart_put_string(str);
#endif

    /* Check whether the OTB bank is valid */
    success &= mpu6050_getOTPBankValid(&otpValid);
#if (DEBUG_IMU == 1)
    if (otpValid) {
	app_uart_put_string("IMU OTP bank is valid\r\n");
    } else {
	app_uart_put_string("IMU OPT bank is invalid\r\n");
    }
#endif

    /* Read the gyroscope offsets for all three axes */
    success &= mpu6050_getXGyroOffsetTC(&xgOffsetTC);
    success &= mpu6050_getYGyroOffsetTC(&ygOffsetTC);
    success &= mpu6050_getZGyroOffsetTC(&zgOffsetTC);
#if (DEBUG_IMU == 1)
    snprintf(str, sizeof(str), "IMU X gyro offset: %d\r\n", xgOffsetTC);
    app_uart_put_string(str);
    snprintf(str, sizeof(str), "IMU Y gyro offset: %d\r\n", ygOffsetTC);
    app_uart_put_string(str);
    snprintf(str, sizeof(str), "IMU Z gyro offset: %d\r\n", zgOffsetTC);
    app_uart_put_string(str);
#endif

    /* Setup weird I2C slave stuff.  The exact purpose of this is unknown. */

    /* Set slave 0 address to 0x7F */
    success &= mpu6050_writeReg(MPU6050_I2C_SLV0_ADDR_REG_ADDR, 0x7F);
    /* Disable I2C master mode */
    success &= mpu6050_clearBits(MPU6050_USER_CTRL_REG_ADDR, (1<<MPU6050_I2C_MST_EN_POSN));
    /* Set slave 0 address to own address */
    success &= mpu6050_writeReg(MPU6050_I2C_SLV0_ADDR_REG_ADDR, mpu6050_getAddress());
    /* Reset I2C master */
    success &= mpu6050_resetI2CMaster();
#if (ORIGINAL_DMP_CODE == 1)
    nrf_delay_ms(20);
#endif

    /* */
    if (mpu6050_writeMemoryBlock(dmpMemory, MPU6050_DMP_CODE_SIZE, 0, 0, true)) {
#if (DEBUG_IMU == 1)
	app_uart_put_string("IMU DMP code written and verified\r\n");
#endif
	if (imu_writeDMPConfigurationSet(dmpConfig, MPU6050_DMP_CONFIG_SIZE)) {
#if (DEBUG_IMU == 1)
	    app_uart_put_string("IMU DMP configuration written and verified\r\n");
#endif

#if (ORIGINAL_DMP_CODE == 1)
	    /* Set clock source to Z-axis gyroscope */
	    success &= mpu6050_setClockSource(MPU6050_CLK_SEL_PLL_ZGYRO);
#else
	    /* Set the clock source to the internal relaxation oscillator.  We
	     * do this because after configuring the DMP, we do not want to
	     * need to keep the gyroscopes on. */
	    success &= mpu6050_setClockSource(MPU6050_CLK_SEL_INTERNAL_8MHZ);
#endif

#if (ORIGINAL_DMP_CODE == 1)
	    /* Enable the DMP and FIFO overflow interrupts */
	    success &= mpu6050_setBits(MPU6050_INT_ENABLE_REG_ADDR,
				       (1<<MPU6050_DMP_INT_EN_POSN) | (1<<MPU6050_FIFO_OFLOW_EN_POSN));
#else
	    /* Enable the FIFO overflow interrupt */
	    success &= mpu6050_setBits(MPU6050_INT_ENABLE_REG_ADDR, (1<<MPU6050_FIFO_OFLOW_EN_POSN));
#endif

	    /* Set the sample rate to 200Hz (1kHZ / (4+1) = 200Hz)*/
	    success &= mpu6050_writeReg(MPU6050_SMPLRT_DIV_REG_ADDR, 4);

#if (ORIGINAL_DMP_CODE == 1)
	    /* Set the external frame sync to appear in the LSB of the temperature data*/
	    success &= mpu6050_setExternalFrameSync(MPU6050_EXT_SYNC_SET_TEMP_OUT_L);
#endif

	    /* Set the digital low pass filter's bandwidth (44Hz for the
	     * accelerometers, 42Hz for the gyroscopes) */
	    success &= mpu6050_setDLPFMode(MPU6050_DLPF_CFG_44HZ_42HZ);

	    /* Set the gyroscopes' full-scale range to +/- 2000 deg/sec */
	    success &= mpu6050_setFullScaleGyroRange(MPU6050_FS_SEL_2000DEGPERSEC);

	    /* Set the DMP configuration bytes--the rationale behind this is
	     * unknown. */
	    success &= mpu6050_writeReg(MPU6050_DMP_CFG_1_REG_ADDR, 0x03);
	    success &= mpu6050_writeReg(MPU6050_DMP_CFG_2_REG_ADDR, 0x00);

	    /* Clear the OTP bank valid flag */
	    success &= mpu6050_setOTPBankValid(false);

	    /* Re-set the gyro offsets from the values read from the same
	     * registers earlier. */
	    success &= mpu6050_setXGyroOffsetTC(xgOffsetTC);
	    success &= mpu6050_setYGyroOffsetTC(ygOffsetTC);
	    success &= mpu6050_setZGyroOffsetTC(zgOffsetTC);

	    success &= mpu6050_writeMemoryBlock(dmpUpdates[0]->data, dmpUpdates[0]->size, dmpUpdates[0]->bank, dmpUpdates[0]->address, true);
	    success &= mpu6050_writeMemoryBlock(dmpUpdates[1]->data, dmpUpdates[1]->size, dmpUpdates[1]->bank, dmpUpdates[1]->address, true);

	    success &= mpu6050_resetFIFO();

	    success &= mpu6050_getFIFOCount(&fifoCount);
#if (DEBUG_IMU == 1)
	    snprintf(str, sizeof(str), "IMU FIFO count after FIFO reset: %u\r\n", fifoCount);
	    app_uart_put_string(str);
#endif

	    success &= mpu6050_getFIFOBytes(fifoBuffer, fifoCount);

#if (ORIGINAL_DMP_CODE == 1)
	    success &= mpu6050_writeReg(MPU6050_MOT_THR_REG_ADDR, 2);
	    success &= mpu6050_writeReg(MPU6050_ZRMOT_THR_REG_ADDR, 156);
	    success &= mpu6050_writeReg(MPU6050_MOT_DUR_REG_ADDR, 80);
	    success &= mpu6050_writeReg(MPU6050_ZRMOT_DUR_REG_ADDR, 0);
#endif

	    success &= mpu6050_resetFIFO();

	    success &= mpu6050_setFIFOEnabled(true);

	    success &= mpu6050_setDMPEnabled(true);

	    success &= mpu6050_resetDMP();

	    success &= mpu6050_writeMemoryBlock(dmpUpdates[2]->data, dmpUpdates[2]->size, dmpUpdates[2]->bank, dmpUpdates[2]->address, true);
	    success &= mpu6050_writeMemoryBlock(dmpUpdates[3]->data, dmpUpdates[3]->size, dmpUpdates[3]->bank, dmpUpdates[3]->address, true);
	    success &= mpu6050_writeMemoryBlock(dmpUpdates[4]->data, dmpUpdates[4]->size, dmpUpdates[4]->bank, dmpUpdates[4]->address, true);

#if (DEBUG_IMU == 1)
	    app_uart_put_string("IMU waiting for FIFO count > 2\r\n");
#endif
	    do {
		success &= mpu6050_getFIFOCount(&fifoCount);
	    } while (fifoCount < 3);
	    success &= mpu6050_getFIFOBytes(fifoBuffer, fifoCount);

#if (DEBUG_IMU == 1)
	    snprintf(str, sizeof(str), "IMU FIFO count after loading updates 3-5: %u\r\n", fifoCount);
	    app_uart_put_string(str);
#endif

	    success &= mpu6050_readReg(MPU6050_INT_STATUS_REG_ADDR, &intStatus);
#if (DEBUG_IMU == 1)
	    snprintf(str, sizeof(str), "IMU interrupt status: 0x%02x\r\n", intStatus);
	    app_uart_put_string(str);
#endif

	    uint8_t dummyData[2];
	    success &= mpu6050_readMemoryBlock(dummyData, dmpUpdates[5]->size, dmpUpdates[5]->bank, dmpUpdates[5]->address);

#if (DEBUG_IMU == 1)
	    app_uart_put_string("IMU waiting for FIFO count > 2\r\n");
#endif
	    do {
		success &= mpu6050_getFIFOCount(&fifoCount);
	    } while (fifoCount < 3);
	    success &= mpu6050_getFIFOBytes(fifoBuffer, fifoCount);

#if (DEBUG_IMU == 1)
	    snprintf(str, sizeof(str), "IMU FIFO count after reading(?) update 6: %u\r\n", fifoCount);
	    app_uart_put_string(str);
#endif

	    success &= mpu6050_readReg(MPU6050_INT_STATUS_REG_ADDR, &intStatus);
#if (DEBUG_IMU == 1)
	    snprintf(str, sizeof(str), "IMU interrupt status: 0x%02x\r\n", intStatus);
	    app_uart_put_string(str);
#endif

	    success &= mpu6050_writeMemoryBlock(dmpUpdates[6]->data, dmpUpdates[6]->size, dmpUpdates[6]->bank, dmpUpdates[6]->address, true);

	    /* Disable DMP for now, it can be re-enabled later */
	    success &= mpu6050_setDMPEnabled(false);

	    success &= mpu6050_resetFIFO();
	    success &= mpu6050_readReg(MPU6050_INT_STATUS_REG_ADDR, &intStatus);

	} else {
	    success = false;
#if (DEBUG_IMU == 1)
	    app_uart_put_string("IMP DMP configuration verification failed\r\n");
#endif
	}

    } else {
	success = false;
#if (DEBUG_IMU == 1)
	app_uart_put_string("IMP DMP code verification failed\r\n");
#endif
    }

#if (DEBUG_IMU == 1)
    if (success) {
	app_uart_put_string("IMU DMP initialization complete\r\n");
    } else {
	app_uart_put_string("IMU DMP initialization failed\r\n");
    }
#endif

    if (success) {
	imu_setDMPInitialized(true);
    } else {
	imu_setDMPInitialized(false);
    }

    twi_master_deinit();

    return success;
}

bool imu_enableMotionDetection(bool enable) {
    uint8_t data;
    bool success = true;

    if (!imu_getIMUInitialized()) {
	return false;
    }

    twi_master_init();

    /* Clear the sleep and cycle bits in order to keep the IMU awake while we
     * configure motion detection. */
    mpu6050_setSleepEnabled(false);
    mpu6050_setCycleEnabled(false);

    /* Bring all three accelerometers out of standby */
    success &= mpu6050_clearBits(MPU6050_PWR_MGMT_2_REG_ADDR,
				 (1<<MPU6050_STBY_XA_POSN) | (1<<MPU6050_STBY_YA_POSN) |	(1<<MPU6050_STBY_ZA_POSN));

    /* Set the accelerometer full-scale value to +/- 2g */
    //success &= mpu6050_setFullScaleAccelRange(MPU6050_AFS_SEL_2G);

    /* Reset the accelerometers' digital high pass filter */
    success &= mpu6050_setAccelHPFMode(MPU6050_ACCEL_HPF_RESET);

    /* Set the digital low-pass filter to 260 Hz for the accelerometers */
    success &= mpu6050_setDLPFMode(MPU6050_DLPF_CFG_260HZ_256HZ);

    /* Enable the motion detection interrupt */
    success &= mpu6050_setBits(MPU6050_INT_ENABLE_REG_ADDR, (1<<MPU6050_MOT_EN_POSN));

    /* Set the motion detection duration threshold to 1 sample */
    success &= mpu6050_writeReg(MPU6050_MOT_DUR_REG_ADDR, 0x01);

    /* Set the motion threshold in terms of LSBs, where 1 LSB is 32mg. */
    success &= mpu6050_writeReg(MPU6050_MOT_THR_REG_ADDR, 20);

    /* Accumulate some accelerometer samples so that we have a reference value
     * against which to compare when sensing motion. */
    nrf_delay_ms(5);

    /* Set the accelerometers' digital high pass filter to hold its current
     * sample.  All future output samples will be the difference between the
     * input sample and the held sample. Leaving the accelerometer full scale
     * value unchanged. */
    success &= mpu6050_setAccelHPFMode(MPU6050_ACCEL_HPF_HOLD);

    /* Configure the wake-up frequency to 1.25Hz */
    success &= mpu6050_setWakeupFrequency(MPU6050_LP_WAKE_CTRL_5HZ);

    /* Put the gyroscopes into standby to save power */
    success &= mpu6050_setBits(MPU6050_PWR_MGMT_2_REG_ADDR,
			       (1<<MPU6050_STBY_XG_POSN) | (1<<MPU6050_STBY_YG_POSN) |	(1<<MPU6050_STBY_ZG_POSN));

    /* Set the CYCLE bit so that the IMU goes to sleep and routinely wakes up
     * to sample the accelerometers and determine whether motion has occurred.
     */
    success &= mpu6050_setCycleEnabled(true);

    /* Clear any pending interrupt flag */
    success &= mpu6050_readReg(MPU6050_INT_STATUS_REG_ADDR, &data);

    twi_master_deinit();

    return success;
}

bool imu_enableDMP() {
    bool success = true;

    if (!(imu_getIMUInitialized() && imu_getDMPInitialized())) {
	return false;
    }

    twi_master_init();

    /* Disable cycle mode in which the IMU sleeps for large periods of time and
     * periodically wakes up to take a quick reading.  While the DMP is enabled,
     * the accelerometer needs to always be on. */
    success &= mpu6050_setSleepEnabled(false);
    success &= mpu6050_setCycleEnabled(false);

    /* Bring all accelerometers and gyros out of standby mode */
    success &= mpu6050_clearBits(MPU6050_PWR_MGMT_2_REG_ADDR,
				 (1<<MPU6050_STBY_XA_POSN) | (1<<MPU6050_STBY_YA_POSN) | (1<<MPU6050_STBY_ZA_POSN) |
				 (1<<MPU6050_STBY_XG_POSN) | (1<<MPU6050_STBY_YG_POSN) | (1<<MPU6050_STBY_ZG_POSN));

    /* Using one of the gyroscopes as the clock source instead of the internal
     * 8MHz relaxation oscillator leads to increased accuracy at the expense of
     * power. */
    success &= mpu6050_setClockSource(MPU6050_CLK_SEL_PLL_ZGYRO);

    /* Enable the FIFO overflow interrupt */
    success &= mpu6050_setBits(MPU6050_INT_ENABLE_REG_ADDR, (1<<MPU6050_FIFO_OFLOW_EN_POSN));

    /* Reset the FIFO which may be holding old DMP data */
    success &= mpu6050_resetFIFO();

    /* Start the DMP running */
    success &= mpu6050_setDMPEnabled(true);

    twi_master_deinit();

    return success;
}

bool imu_enableSleepMode() {
    uint8_t data;
    bool success = true;

    if (!imu_getIMUInitialized()) {
	return false;
    }

    twi_master_init();

    /* Stop the DMP running */
    success &= mpu6050_setDMPEnabled(false);

    /* Reset the FIFO to remove old DMP data */
    success &= mpu6050_resetFIFO();

    /* Disable all interrupts */
    success &= mpu6050_writeReg(MPU6050_INT_ENABLE_REG_ADDR, 0x00);

    /* Clear any pending interrupt flag by reading the flag register */
    success &= mpu6050_readReg(MPU6050_INT_STATUS_REG_ADDR, &data);

    /* Return to using the internal 8MHz relaxation oscillator so that we can
     * disable the gyroscopes (one of which may have been supplying the
     * clock). */
    success &= mpu6050_setClockSource(MPU6050_CLK_SEL_INTERNAL_8MHZ);

    /* Place all accelerometers and gyros into standby mode */
    success &= mpu6050_setBits(MPU6050_PWR_MGMT_2_REG_ADDR,
			       (1<<MPU6050_STBY_XA_POSN) | (1<<MPU6050_STBY_YA_POSN) | (1<<MPU6050_STBY_ZA_POSN) |
			       (1<<MPU6050_STBY_XG_POSN) | (1<<MPU6050_STBY_YG_POSN) | (1<<MPU6050_STBY_ZG_POSN));

    /* Disable cycle mode and place device into sleep */
    success &= mpu6050_setCycleEnabled(false);
    success &= mpu6050_setSleepEnabled(true);

    twi_master_deinit();

    return success;
}

bool imu_checkForMotion(bool *motionDetected) {
    uint8_t data;
    bool success;

    if (!imu_getIMUInitialized()) {
	return false;
    }

    twi_master_init();

    success = mpu6050_readReg(MPU6050_INT_STATUS_REG_ADDR, &data);
    if (data & MPU6050_MOT_INT_MASK) {
	*motionDetected = true;
    } else {
	*motionDetected = false;
    }

    twi_master_deinit();
    return success;
}

bool imu_getLatestFIFOPacket(uint8_t *packet) {
    bool success = true;
    bool dmpEnabled, fifoEnabled;
    uint16_t fifoCount;
    uint8_t intStatus;


    if (!(imu_getIMUInitialized() && imu_getDMPInitialized())) {
	return false;
    }

    twi_master_init();

    /* Return indicating failure if the DMP is not running or the FIFO is not
     * enabled. */
    success &= mpu6050_getDMPEnabled(&dmpEnabled);
    success &= mpu6050_getFIFOEnabled(&fifoEnabled);
    if (!success || !dmpEnabled || !fifoEnabled) {
	return false;
    }

    /* Read the interrupt flags and the number of bytes in the FIFO so that we
     * can check for FIFO overflow. */
    success &= mpu6050_readReg(MPU6050_INT_STATUS_REG_ADDR, &intStatus);
    success &= mpu6050_getFIFOCount(&fifoCount);

    /* If we fail to read the interrupt status register or the number of bytes
     * in the FIFO, we return failure without providing the caller with the
     * newest packet. */
    if (!success) {
	return false;
    }

    /* If the FIFO has overflowed, reset it */
    if ((intStatus & (1<<MPU6050_FIFO_OFLOW_INT_POSN)) || (fifoCount >= 1024)) {
	mpu6050_resetFIFO();
	fifoCount = 0;
    }

    /* Wait until the FIFO contains at least a single complete packet. */
    while (fifoCount < IMU_FIFO_PACKET_SIZE) {
	/* If we fail to read the number of bytes in the FIFO, return false
	 * without providing the caller with the most recent FIFO packet. */
	if (!mpu6050_getFIFOCount(&fifoCount)) {
	    return false;
	}
    }

    /* Read packets from the FIFO until there are no complete packets
     * remaining. */
    do {
	/* Read the oldest packet from the FIFO.  If we fail to do so, return
	 * false whithout providing the caller with the most recent packet. */
	if (!mpu6050_getFIFOBytes(packet, IMU_FIFO_PACKET_SIZE)) {
	    return false;
	}

	/* Having read a packet, decrement the number of bytes in the FIFO by
	 * the packet's size.  We will read another packet if the new count is
	 * still equal to or larger than the size of a single packet. */
	fifoCount -= IMU_FIFO_PACKET_SIZE;
    } while (fifoCount >= IMU_FIFO_PACKET_SIZE);

    twi_master_deinit();

    return true;
}

bool imu_getGyros16(vector16_t *v16) {
    imuFIFOPacket_t packet;

    if (v16 == NULL) {
	return false;
    }

    if (!imu_getLatestFIFOPacket(packet)) {
	return false;
    }

    return imu_getGyros16FromPacket(v16, packet);
}

bool imu_getGyros16FromPacket(vector16_t *v16, const uint8_t *packet) {
    int16_t x_raw, y_raw, z_raw;

    x_raw = ((int16_t)packet[16] << 8) + (int16_t)packet[17];
    y_raw = ((int16_t)packet[20] << 8) + (int16_t)packet[21];
    z_raw = ((int16_t)packet[24] << 8) + (int16_t)packet[25];

    v16->x = 2*x_raw;
    v16->y = 2*y_raw;
    v16->z = 2*z_raw;

    return true;
}

bool imu_getGyrosFloat(vectorFloat_t *vf) {
    imuFIFOPacket_t packet;

    if (vf == NULL) {
	return false;
    }

    if (!imu_getLatestFIFOPacket(packet)) {
	return false;
    }

    return imu_getGyrosFloatFromPacket(vf, packet);
}

bool imu_getGyrosFloatFromPacket(vectorFloat_t *vf, const uint8_t *packet) {
    vector16_t v16;

    if (!imu_getGyros16FromPacket(&v16, packet)) {
	return false;
    }

    vf->x = (float)v16.x / 32768.0f;
    vf->y = (float)v16.y / 32768.0f;
    vf->z = (float)v16.z / 32768.0f;

    return true;
}

bool imu_getUnitQuaternion16(quaternion16_t *q16) {
    imuFIFOPacket_t packet;

    if (q16 == NULL) {
	return false;
    }

    if (!imu_getLatestFIFOPacket(packet)) {
	return false;
    }

    return imu_getUnitQuaternion16FromPacket(q16, packet);
}

bool imu_getUnitQuaternion16FromPacket(quaternion16_t *q16, const uint8_t *packet) {
    int16_t w_raw, x_raw, y_raw, z_raw;

    w_raw = ((int16_t)packet[0] << 8) + (int16_t)packet[1];
    x_raw = ((int16_t)packet[4] << 8) + (int16_t)packet[5];
    y_raw = ((int16_t)packet[8] << 8) + (int16_t)packet[9];
    z_raw = ((int16_t)packet[12] << 8) + (int16_t)packet[13];

    /* We multiply by 2 in order to get full-scale int16's.  That is, before
     * the multiplication, the maximum value of the raw measurements is
     * +/-16,384, which is only half the maximum value of an int16. */
    q16->w = 2*w_raw;
    q16->x = 2*x_raw;
    q16->y = 2*y_raw;
    q16->z = 2*z_raw;

    return true;
}

bool imu_getUnitQuaternionFloat(quaternionFloat_t *qf) {
    imuFIFOPacket_t packet;

    if (qf == NULL) {
	return false;
    }

    if (!imu_getLatestFIFOPacket(packet)) {
	return false;
    }

    return imu_getUnitQuaternionFloatFromPacket(qf, packet);
}

bool imu_getUnitQuaternionFloatFromPacket(quaternionFloat_t *qf, const uint8_t *packet) {
    quaternion16_t q16;

    if (!imu_getUnitQuaternion16FromPacket(&q16, packet)) {
	return false;
    }

    qf->w = (float)q16.w / 32768.0f;
    qf->x = (float)q16.x / 32768.0f;
    qf->y = (float)q16.y / 32768.0f;
    qf->z = (float)q16.z / 32768.0f;

    return true;
}

bool imu_getGravity16(vector16_t *v16) {
    imuFIFOPacket_t packet;

    if (v16 == NULL) {
	return false;
    }

    if (!imu_getLatestFIFOPacket(packet)) {
	return false;
    }

    return imu_getGravity16FromPacket(v16, packet);
}

bool imu_getGravity16FromPacket(vector16_t *v16, const uint8_t *packet) {
    vectorFloat_t vf;

    if (!imu_getGravityFloatFromPacket(&vf, packet)) {
	return false;
    }

    v16->x = (int16_t)(vf.x * 32768.0f);
    v16->y = (int16_t)(vf.y * 32768.0f);
    v16->z = (int16_t)(vf.z * 32768.0f);

    return true;
}

bool imu_getGravityFloat(vectorFloat_t *vf) {
    imuFIFOPacket_t packet;

    if (vf == NULL) {
	return false;
    }

    if (!imu_getLatestFIFOPacket(packet)) {
	return false;
    }

    return imu_getGravityFloatFromPacket(vf, packet);
}

bool imu_getGravityFloatFromPacket(vectorFloat_t *vf, const uint8_t *packet) {
    quaternionFloat_t qf;

    if ((vf == NULL) || (packet == NULL)) {
	return false;
    }

    imu_getUnitQuaternionFloatFromPacket(&qf, packet);

    vf->x = 2 * (qf.x * qf.z - qf.w * qf.y);
    vf->y = 2 * (qf.w * qf.x + qf.y * qf.z);
    vf->z = qf.w * qf.w - qf.x * qf.x - qf.y * qf.y + qf.z * qf.z;

    return true;
}

float imu_getVectorFloatAngle(const vectorFloat_t *v, const vectorFloat_t *u) {
    float dotProduct;
    float vMag, uMag;

    vMag = imu_getVectorFloatMagnitude(v);
    uMag = imu_getVectorFloatMagnitude(u);

    dotProduct = (v->x * u->x) + (v->y * u->y) + (v->z * u->z);

    return (180.0 / M_PI) * acosf(dotProduct / (uMag * vMag));
}

float imu_getVectorFloatMagnitude(const vectorFloat_t *v) {
    return sqrtf((v->x * v->x) + (v->y * v->y) + (v->z * v->z));
}

void imu_testDMPLoop() {
    char str[64];
    uint8_t packetBuffer[IMU_FIFO_PACKET_SIZE];
    quaternionFloat_t qf;
    vectorFloat_t gravity;
    bool success = true;

    success = mpu6050_setDMPEnabled(true);

    while (success) {
	success &= imu_getLatestFIFOPacket(packetBuffer);
	success &= imu_getUnitQuaternionFloatFromPacket(&qf, packetBuffer);

#if (0)
	snprintf(str, sizeof(str), "Quaternion: %5.4f %5.4f %5.4f %5.4f\r\n", qf.w, qf.x, qf.y, qf.z);
	app_uart_put_string(str);
#endif

	success &= imu_getGravityFloatFromPacket(&gravity, packetBuffer);

	snprintf(str, sizeof(str), "Gravity: %5.4f %5.4f %5.4f\r\n", gravity.x, gravity.y, gravity.z);
	app_uart_put_string(str);

	snprintf(str, sizeof(str), "Alignment angles: %4.1f %4.1f %4.1f\r\n",
		 imu_getVectorFloatAngle(&gravity, &frameAlignmentVectorsFloat[0]),
		 imu_getVectorFloatAngle(&gravity, &frameAlignmentVectorsFloat[1]),
		 imu_getVectorFloatAngle(&gravity, &frameAlignmentVectorsFloat[2])
	    );
	app_uart_put_string(str);

	nrf_delay_ms(250);
    }
}

bool imu_writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize) {
    uint8_t *progBuffer, special;
    uint16_t i;
    uint8_t bank, offset, length;
    bool success = true;

    // config set data is a long string of blocks, each with the following structure:
    // {bank} {offset} {length} {byte[0], byte[1], ..., byte[length-1] | special}
    for (i = 0; i < dataSize;) {
	bank = data[i++];
	offset = data[i++];
	length = data[i++];

        // write data or perform special action
        if (length > 0) {
            // regular block of data to write
            progBuffer = (uint8_t *)data + i;
            success &= mpu6050_writeMemoryBlock(progBuffer, length, bank, offset, true);
            i += length;
        } else {
            // special instruction
            // NOTE: this kind of behavior (what and when to do certain things)
            // is totally undocumented. This code is in here based on observed
            // behavior only, and exactly why (or even whether) it has to be here
            // is anybody's guess for now.

            special = data[i++];
            if (special == 0x01) {
                // enable DMP-related interrupts
            	success &= mpu6050_writeReg(MPU6050_INT_ENABLE_REG_ADDR,
					    (1<<MPU6050_ZMOT_EN_POSN) | (1<<MPU6050_FIFO_OFLOW_EN_POSN) | (1<<MPU6050_DMP_INT_EN_POSN));
            } else {
                success = false;
            }
        }
    }

    return success;
}


void imu_setIMUInitialized(bool initialized) {
    if (mpu6050_getAddress() == MPU6050_I2C_ADDR_CENTRAL) {
	imuInitialized[0] = initialized;
    } else if (mpu6050_getAddress() == MPU6050_I2C_ADDR_FACE) {
	imuInitialized[1] = initialized;
    }
}

bool imu_getIMUInitialized() {
    if (mpu6050_getAddress() == MPU6050_I2C_ADDR_CENTRAL) {
	return imuInitialized[0];
    } else if (mpu6050_getAddress() == MPU6050_I2C_ADDR_FACE) {
	return imuInitialized[1];
    } else {
	return false;
    }
}

void imu_setDMPInitialized(bool initialized) {
    if (mpu6050_getAddress() == MPU6050_I2C_ADDR_CENTRAL) {
	dmpInitialized[0] = initialized;
    } else if (mpu6050_getAddress() == MPU6050_I2C_ADDR_FACE) {
	dmpInitialized[1] = initialized;
    }
}

bool imu_getDMPInitialized() {
    if (mpu6050_getAddress() == MPU6050_I2C_ADDR_CENTRAL) {
	return dmpInitialized[0];
    } else if (mpu6050_getAddress() == MPU6050_I2C_ADDR_FACE) {
	return dmpInitialized[1];
    } else {
	return false;
    }
}
